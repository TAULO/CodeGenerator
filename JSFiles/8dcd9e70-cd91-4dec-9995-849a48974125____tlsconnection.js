/* This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/. */

// These tests exercise the ClientConnection and ServerConnection classes
// using known-good test vectors generated by the python `tlslite-ng` module.
// See `./vectors/test_vectors.py` for details on generating them.

describe('the Connection base class', () => {
  it('rejects non-Uint8Array values for PSK', () => {
    assert.throws(() => {
      return new Connection('my psk', TEST_VECTORS.PSK_ID);
    }, Error, /value must be a Uint8Array/);
  });

  it('rejects non-Uint8Array values for PSK id', () => {
    assert.throws(() => {
      return new Connection(TEST_VECTORS.PSK, 'my psk id');
    }, Error, /value must be a Uint8Array/);
  });

  describe('when instantiated correctly', () => {
    let conn;
    beforeEach(() => {
      conn = new Connection(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID);
    });

    it('rejects string values as received data', async () => {
      await assert.throwsAsync(async () => {
        await conn.recv('string data');
      }, Error, /value must be a Uint8Array/);
    });

    it('rejects non-Uint8Array object values as received data', async () => {
      await assert.throwsAsync(async () => {
        await conn.recv({ accidental: 'object instead of bytes' });
      }, Error, /value must be a Uint8Array/);
    });

    it('rejects string values as sent data', async () => {
      await assert.throwsAsync(async () => {
        await conn.send('string data');
      }, Error, /value must be a Uint8Array/);
    });

    it('rejects non-Uint8Array object values as sent data', async () => {
      await assert.throwsAsync(async () => {
        await conn.send({ accidental: 'object instead of bytes' });
      }, Error, /value must be a Uint8Array/);
    });

    it('errors out if receiving without initializing the state-machine', async () => {
      await assert.throwsAsync(async () => {
        await conn.recv(TEST_VECTORS.CLIENT_HELLO);
      }, Error, /uninitialized state/);
    });

    it('errors out if closing without initializing the state-machine', async () => {
      await assert.throwsAsync(async () => {
        await conn.close();
      }, Error, /uninitialized state/);
    });
  });
});

describe('the ServerConnection class', () => {
  let server, SERVER_SENT;

  beforeEach(async () => {
    SERVER_SENT = [];
    sinon.stub(crypto, 'getRandomValues').callsFake(arr => {
      arr.set(TEST_VECTORS.SERVER_RANDOM);
    });
    server = await ServerConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => SERVER_SENT.push(data));
  });

  afterEach(() => {
    crypto.getRandomValues.restore();
  });

  it('does not send any initial data', async () => {
    assert.equal(SERVER_SENT.length, 0);
  });

  describe('accepts a valid ClientHello message, and then', () => {
    let clientHandshakeTrafficSecret;

    beforeEach(async () => {
      const data = await server.recv(TEST_VECTORS.CLIENT_HELLO);
      assert.equal(data, null);
      clientHandshakeTrafficSecret = server._state._clientHandshakeTrafficSecret;
    });

    it('calls crypto.getRandomValues to generate a strong random salt', async () => {
      assert.equal(crypto.getRandomValues.callCount, 1);
    });

    it('sends ServerHello, ChangeCipherSpec, EncryptedExtensions, and Finished', async () => {
      assert.equal(SERVER_SENT.length, 3);
      assert.ok(bytesAreEqual(SERVER_SENT[0], TEST_VECTORS.SERVER_HELLO));
      assert.ok(bytesAreEqual(SERVER_SENT[1], TEST_VECTORS.SERVER_CHANGE_CIPHER_SPEC));
      assert.ok(bytesAreEqual(SERVER_SENT[2], TEST_VECTORS.SERVER_ENCRYPTED_EXTENSIONS_AND_FINISHED));
    });

    describe('accepts a valid client Finished message, and then', () => {
      beforeEach(async () => {
        const data = await server.recv(TEST_VECTORS.CLIENT_FINISHED);
        assert.equal(data, null);
      });

      it('can receive application data, calling crypto.subtle.decrypt to do the decryption', async () => {
        sinon.spy(crypto.subtle, 'decrypt');
        try {
          const data = await server.recv(TEST_VECTORS.CLIENT_APP_DATA);
          assert.ok(bytesAreEqual(data, TEST_VECTORS.CLIENT_RAW_APP_DATA));
          assert.equal(crypto.subtle.decrypt.callCount, 1);
        } finally {
          crypto.subtle.decrypt.restore();
        }
      });

      it('can send application data, calling crypto.subtle.encrypt to do the encryption', async () => {
        sinon.spy(crypto.subtle, 'encrypt');
        try {
          await server.send(TEST_VECTORS.SERVER_RAW_APP_DATA);
          assert.equal(SERVER_SENT.length, 4);
          assert.ok(bytesAreEqual(SERVER_SENT[3], TEST_VECTORS.SERVER_APP_DATA));
          assert.equal(crypto.subtle.encrypt.callCount, 1);
        } finally {
          crypto.subtle.encrypt.restore();
        }
      });

      describe('handles first exchange of application data, and then', () => {
        beforeEach(async () => {
          const data = await server.recv(TEST_VECTORS.CLIENT_APP_DATA);
          assert.ok(bytesAreEqual(data, TEST_VECTORS.CLIENT_RAW_APP_DATA));
          await server.send(TEST_VECTORS.SERVER_RAW_APP_DATA);
          assert.equal(SERVER_SENT.length, 4);
          assert.ok(bytesAreEqual(SERVER_SENT[3], TEST_VECTORS.SERVER_APP_DATA));
        });

        describe('handles second exchange of application data, and then', () => {
          beforeEach(async () => {
            const data = await server.recv(TEST_VECTORS.CLIENT_APP_DATA_2);
            assert.ok(bytesAreEqual(data, TEST_VECTORS.CLIENT_RAW_APP_DATA_2));
            await server.send(TEST_VECTORS.SERVER_RAW_APP_DATA_2);
            assert.equal(SERVER_SENT.length, 5);
            assert.ok(bytesAreEqual(SERVER_SENT[4], TEST_VECTORS.SERVER_APP_DATA_2));
          });

          describe('accepts an explicit close alert from the client, and then', () => {
            beforeEach(async () => {
              assert.throwsAsync(async () => {
                await server.recv(TEST_VECTORS.CLIENT_CLOSE);
              }, TLSCloseNotify);
            });

            it('does not accept any additional received data', async () => {
              // Forge a valid record, so we know it fails because of the close, rather than a crypto error.
              const encryptor = await testHelpers.makeEncryptionState(server._keyschedule.clientApplicationTrafficSecret, 3);
              await assert.throwsAsync(async () => {
                await server.recv(await testHelpers.makeEncryptedRecord(encryptor, {}));
              }, TLSCloseNotify);
            });

            it('can still send data', async () => {
              await server.send(TEST_VECTORS.SERVER_RAW_APP_DATA);
              assert.equal(SERVER_SENT.length, 6);
            });

            describe('is able to send an explicit close in return, and then', () => {
              beforeEach(async () => {
                await server.close();
                assert.equal(SERVER_SENT.length, 6);
                assert.ok(bytesAreEqual(SERVER_SENT[5], TEST_VECTORS.SERVER_CLOSE));
              });

              it('rejects any further attempts to send data', async () => {
                await assert.throwsAsync(async () => {
                  await server.send(TEST_VECTORS.SERVER_RAW_APP_DATA);
                }, TLSCloseNotify);
              });
            });
          });

          describe('is able to send an explicit close to the client, and then', () => {
            beforeEach(async () => {
              await server.close();
              assert.equal(SERVER_SENT.length, 6);
              assert.ok(bytesAreEqual(SERVER_SENT[5], TEST_VECTORS.SERVER_CLOSE));
            });

            it('rejects any further attempts to send data', async () => {
              await assert.throwsAsync(async () => {
                await server.send(TEST_VECTORS.SERVER_RAW_APP_DATA);
              }, TLSCloseNotify);
            });

            it('can still receive data', async () => {
              const encryptor = await testHelpers.makeEncryptionState(server._keyschedule.clientApplicationTrafficSecret, 2);
              const data = await server.recv(await testHelpers.makeEncryptedRecord(encryptor, {
                content: utf8ToBytes('hello world')
              }));
              assert.equal(bytesToUtf8(data), 'hello world');
            });

            describe('can accept an explicit close in return, and then', () => {
              beforeEach(async () => {
                assert.throwsAsync(async () => {
                  await server.recv(TEST_VECTORS.CLIENT_CLOSE);
                }, TLSCloseNotify);
              });

              it('does not accept any additional received data', async () => {
                const encryptor = await testHelpers.makeEncryptionState(server._keyschedule.clientApplicationTrafficSecret, 3);
                await assert.throwsAsync(async () => {
                  await server.recv(await testHelpers.makeEncryptedRecord(encryptor, {}));
                }, TLSCloseNotify);
              });
            });
          });
        });

        it('rejects an out-of-order close notification', async () => {
          // The `TEST_VECTORS.CLIENT_CLOSE` record was generated after sending two application
          // data records, but here we're receiving it after only processing one of them.
          await assert.throwsAsync(async () => {
            await server.recv(TEST_VECTORS.CLIENT_CLOSE);
          }, TLSError, 'BAD_RECORD_MAC');
        });

        it('rejects a duplicate application data record', async () => {
          await assert.throwsAsync(async () => {
            await server.recv(TEST_VECTORS.CLIENT_APP_DATA);
          }, TLSError, 'BAD_RECORD_MAC');
        });
      });

      it('errors if it receives another handshake message', async () => {
        const encryptor = await testHelpers.makeEncryptionState(server._keyschedule.clientApplicationTrafficSecret, 0);
        await assert.throwsAsync(async () => {
          await server.recv(await testHelpers.makeEncryptedRecord(encryptor, {
            content: new Finished(zeros(32)).toBytes(),
            type: 22,
          }));
        }, TLSError, 'UNEXPECTED_MESSAGE');
      });

      it('errors if a data record is received out-of-order', async () => {
        await assert.throwsAsync(async () => {
          await server.recv(TEST_VECTORS.CLIENT_APP_DATA_2);
        }, TLSError, 'BAD_RECORD_MAC');
      });

      it('errors if a data record is tampered with', async () => {
        await assert.throwsAsync(async () => {
          await server.recv(testHelpers.tamper(TEST_VECTORS.CLIENT_APP_DATA, 5));
        }, TLSError, 'BAD_RECORD_MAC');
      });

      it('errors if change_cipher_spec is received after handshake completion', async () => {
        await assert.throwsAsync(async () => {
          await server.recv(TEST_VECTORS.CLIENT_CHANGE_CIPHER_SPEC);
        }, TLSError, 'UNEXPECTED_MESSAGE');
      });
    });

    it('errors if it receives a plaintext handshake message', async () => {
      await assert.throwsAsync(async () => {
        await server.recv(TEST_VECTORS.CLIENT_HELLO);
      }, TLSError, 'DECODE_ERROR');
    });

    it('errors if it receives a message other than Finished', async () => {
      const encryptor = await testHelpers.makeEncryptionState(clientHandshakeTrafficSecret, 0);
      await assert.throwsAsync(async () => {
        await server.recv(await testHelpers.makeEncryptedRecord(encryptor, {
          content: new EncryptedExtensions([]).toBytes(),
          type: 22,
        }));
      }, TLSError, 'UNEXPECTED_MESSAGE');
    });

    it('would error out if some bug caused it to try to send application data before handshake completion', async () => {
      await assert.throwsAsync(async () => {
        await server._state.sendApplicationData(zeros(12));
      }, TLSError, 'INTERNAL_ERROR');
    });

    it('cant yet decrypt application data, since it does not have the right keys', async () => {
      await assert.throwsAsync(async () => {
        await server.recv(TEST_VECTORS.CLIENT_APP_DATA);
      }, TLSError, 'BAD_RECORD_MAC');
    });

    it('errors if it receives application data before the handshake completes', async () => {
      const encryptor = await testHelpers.makeEncryptionState(clientHandshakeTrafficSecret, 0);
      await assert.throwsAsync(async () => {
        await server.recv(await testHelpers.makeEncryptedRecord(encryptor, {}));
      }, TLSError, 'UNEXPECTED_MESSAGE');
    });

    it('accepts and ignores a change_cipher_spec message before the client Finished', async () => {
      let data = await server.recv(TEST_VECTORS.CLIENT_CHANGE_CIPHER_SPEC);
      assert.equal(data, null);
      data = await server.recv(TEST_VECTORS.CLIENT_FINISHED);
      assert.equal(data, null);
      data = await server.recv(TEST_VECTORS.CLIENT_APP_DATA);
      assert.ok(bytesAreEqual(data, TEST_VECTORS.CLIENT_RAW_APP_DATA));
    });

    it('rejects duplicate change_cipher_spec messages', async () => {
      const data = await server.recv(TEST_VECTORS.CLIENT_CHANGE_CIPHER_SPEC);
      assert.equal(data, null);
      assert.throwsAsync(async () => {
        await server.recv(TEST_VECTORS.CLIENT_CHANGE_CIPHER_SPEC);
      }, TLSError, 'UNEXPECTED_MESSAGE');
    });

    it('rejects a change_cipher_spec message that suggests non-TLS1.3 traffic', async () => {
      const changeCipherSpec = testHelpers.makePlaintextRecord({
        content: zeros(3),
        type: 20
      });
      await assert.throwsAsync(async () => {
        await server.recv(changeCipherSpec);
      }, TLSError, 'UNEXPECTED_MESSAGE');
    });

    describe('errors if Finished contains incorrect signature, and then', () => {
      beforeEach(async () => {
        const cipherstate = await testHelpers.makeEncryptionState(clientHandshakeTrafficSecret, 0);
        await assert.throwsAsync(async () => {
          await server.recv(await testHelpers.makeEncryptedRecord(cipherstate, {
            content: new Finished(zeros(32)).toBytes(),
            type: 22,
          }));
        }, TLSError, 'DECRYPT_ERROR');
      });

      it('sends an error alert to the peer', async () => {
        assert.equal(SERVER_SENT.length, 4);
        const decryptor = await testHelpers.makeDecryptionState(server._keyschedule.serverApplicationTrafficSecret, 0);
        const alertMsg = await testHelpers.decryptInnerPlaintext(decryptor, SERVER_SENT[3]);
        assert.equal(alertMsg[0], 2);  // level == fatal
        assert.equal(alertMsg[1], 51); // description == decrypt_error
        assert.equal(alertMsg[2], 21); // record type == alert
        assert.equal(alertMsg.byteLength, 3);
      });

      it('rejects any further attempts to send data', async () => {
        assert.equal(SERVER_SENT.length, 4);
        await assert.throwsAsync(async () => {
          await server.send(TEST_VECTORS.SERVER_RAW_APP_DATA);
        }, TLSError, 'DECRYPT_ERROR');
        assert.equal(SERVER_SENT.length, 4); // No additional data was sent.
      });

      it('rejects any further attempts to recv data', async () => {
        const encryptor = await testHelpers.makeEncryptionState(clientHandshakeTrafficSecret, 1);
        await assert.throwsAsync(async () => {
          await server.recv(await testHelpers.makeEncryptedRecord(encryptor, {}));
        }, TLSError, 'DECRYPT_ERROR');
      });
    });
  });

  it('blocks sending of application data until the handshake completes', async () => {
    let sendComplete = false;
    server.send(TEST_VECTORS.SERVER_RAW_APP_DATA).then(() => {
      sendComplete = true;
    });
    assert.equal(SERVER_SENT.length, 0);
    assert.notOk(sendComplete);

    await server.recv(TEST_VECTORS.CLIENT_HELLO);
    assert.equal(SERVER_SENT.length, 3);
    await testHelpers.nextTick();
    assert.notOk(sendComplete);

    await server.recv(TEST_VECTORS.CLIENT_FINISHED);
    assert.notOk(sendComplete);
    await testHelpers.nextTick();
    assert.ok(sendComplete);
  });

  it('errors if it receives non-TLS-handshake-message data', async () => {
    await assert.throwsAsync(async () => {
      await server.recv(utf8ToBytes('a badly-formed message'));
    }, TLSError, 'DECODE_ERROR');
  });

  it('errors if it receives a message of unknown type', async () => {
    await assert.throwsAsync(async () => {
      await server.recv(await testHelpers.makePlaintextRecord({
        content: zeros(0),
        type: 13
      }));
    }, TLSError, 'UNEXPECTED_MESSAGE');
  });

  it('errors if it receives a badly-formed alert message', async () => {
    await assert.throwsAsync(async () => {
      await server.recv(await testHelpers.makePlaintextRecord({
        content: arrayToBytes([1, 2, 3]),
        type: 21
      }));
    }, TLSError, 'DECODE_ERROR');
  });

  it('errors if it receives an empty record of handshake messages', async () => {
    await assert.throwsAsync(async () => {
      await server.recv(await testHelpers.makePlaintextRecord({
        content: zeros(0),
        type: 22
      }));
    }, TLSError, 'UNEXPECTED_MESSAGE');
  });

  it('accepts a ClientHello advertising lots of TLS1.3 features that we do not support', async () => {
    // This ClientHello was generated from tlslite-ng and contains multiple ciphersuites,
    // keyshares, optional extensions, and other exciting features that we do not support.
    const data = await server.recv(TEST_VECTORS.EXTENDED_CLIENT_HELLO);
    assert.equal(data, null);
    // It sends ServerHello, ChangeCipherSpec, EncryptedExtensions+Finished in response.
    // Ideally we'd generate a static trace of the server responses here,
    // but I haven't yet managed to convince tlslite-ng to do so.
    assert.equal(SERVER_SENT.length, 3);
  });

  it('accepts a ClientHello with extensions listed in a different order', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(32)])
      ]
    }, TEST_VECTORS.PSK);
    const data = await server.recv(clientHello);
    assert.equal(data, null);
    assert.equal(SERVER_SENT.length, 2);
  });

  it('errors if PreSharedKey is not the last extension in the ClientHello', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(32)]),
        testHelpers.makeSupportedVersionsExtension([0x0304])
      ]
    });
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if it receives a message other than ClientHello', async () => {
    await assert.throwsAsync(async () => {
      await server.recv(TEST_VECTORS.SERVER_HELLO);
    }, TLSError, 'UNEXPECTED_MESSAGE');
  });

  it('rejects ChangeCipherSpec before it has received ClientHello', async () => {
    await assert.throwsAsync(async () => {
      await server.recv(TEST_VECTORS.CLIENT_CHANGE_CIPHER_SPEC);
    }, TLSError, 'UNEXPECTED_MESSAGE');
  });

  it('errors if it receives application data before the handshake completes', async () => {
    await assert.throwsAsync(async () => {
      await server.recv(TEST_VECTORS.CLIENT_APP_DATA);
    }, TLSError, 'UNEXPECTED_MESSAGE');
  });

  it('errors if it receives a pre-TLS1 ClientHello', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      version: 0x0102
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'PROTOCOL_VERSION');
  });

  it('errors if ClientHello does not offer any cipher suites', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      ciphersuites: []
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'HANDSHAKE_FAILURE');
  });

  it('errors if ClientHello does not offer a compatible cipher suite', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      ciphersuites: [0x0001, 0x0002, 0x0003]
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'HANDSHAKE_FAILURE');
  });

  it('errors if the client does not offer any compression methods', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      compressionMethods: arrayToBytes([])
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if the client only a legacy compression methods', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      compressionMethods: arrayToBytes([0x01])
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if the client offers any legacy compression methods', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      compressionMethods: arrayToBytes([0x00, 0x01])
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if ClientHello has missing supported_versions extension', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(32)])
      ]
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'MISSING_EXTENSION');
  });

  it('errors if ClientHello has empty supported_versions extension', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([]),
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(32)])
      ]
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'PROTOCOL_VERSION');
  });

  it('errors if ClientHello has incorrect supported_versions extension', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0302, 0x0303]),
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(32)])
      ]
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'PROTOCOL_VERSION');
  });

  it('errors if ClientHello does send the PSK extension', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
      ]
    });
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'MISSING_EXTENSION');
  });

  it('errors if ClientHello does not offer a matching PSK', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makePreSharedKeyExtension([utf8ToBytes('wrong psk')], [zeros(32)])
      ]
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'UNKNOWN_PSK_IDENTITY');
  });

  it('errors if ClientHello has an empty PSK identity', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makePreSharedKeyExtension([], [])
      ]
    });
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'UNKNOWN_PSK_IDENTITY');
  });

  it('errors if ClientHello does not advertise PSK modes', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(32)])
      ]
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'MISSING_EXTENSION');
  });

  it('errors if ClientHello does not offer the expected PSK mode', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePskKeyExchangeModesExtension([0xAB]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(32)])
      ]
    }, TEST_VECTORS.PSK);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'HANDSHAKE_FAILURE');
  });

  it('errors if ClientHello has an invalid PSK binder', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(32)])
      ]
    }); // Don't sign it, leaving invalid PSK binder.
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'DECRYPT_ERROR');
  });

  it('errors if ClientHello has more PSK identities than PSK binders', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID, utf8ToBytes('a second key')], [zeros(32)])
      ]
    });
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if ClientHello has more PSK binders than PSK identities', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(32), zeros(32)])
      ]
    });
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if ClientHello has a binder that is too short', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(24)])
      ]
    });
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if ClientHello has data after the extensions', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(32)])
      ],
      trailer: zeros(12)
    });
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'DECODE_ERROR');
  });

  it('errors if the ClientHello contains duplicate extensions', async () => {
    const clientHello = await testHelpers.makeClientHelloRecord({
      extensions: [
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePskKeyExchangeModesExtension([0x00]),
        testHelpers.makeSupportedVersionsExtension([0x0304]),
        testHelpers.makePreSharedKeyExtension([TEST_VECTORS.PSK_ID], [zeros(32)])
      ],
    }, TEST_VECTORS.PSK_ID);
    await assert.throwsAsync(async () => {
      await server.recv(clientHello);
    }, TLSError, 'DECODE_ERROR');
  });
});

describe('the ClientConnection class', () => {
  let client, CLIENT_SENT;

  beforeEach(async () => {
    CLIENT_SENT = [];
    const RANDOM_VALUES = [TEST_VECTORS.CLIENT_RANDOM, TEST_VECTORS.SESSION_ID];
    sinon.stub(crypto, 'getRandomValues').callsFake(arr => {
      arr.set(RANDOM_VALUES.shift());
    });
    client = await ClientConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => CLIENT_SENT.push(data));
  });

  afterEach(() => {
    crypto.getRandomValues.restore();
  });

  it('calls crypto.getRandomValues to generate a strong random salt and session id', async () => {
    assert.equal(crypto.getRandomValues.callCount, 2);
    assert.equal(crypto.getRandomValues.getCall(0).args[0].byteLength, 32);
    assert.equal(crypto.getRandomValues.getCall(1).args[0].byteLength, 32);
  });

  it('immediately sends an initial ClientHello', async () => {
    assert.equal(CLIENT_SENT.length, 1);
    assert.ok(bytesAreEqual(CLIENT_SENT[0], TEST_VECTORS.CLIENT_HELLO));
  });

  describe('accepts a ServerHello message, and then', () => {
    beforeEach(async () => {
      const data = await client.recv(TEST_VECTORS.SERVER_HELLO);
      assert.equal(data, null);
    });

    describe('accepts EncryptedExtensions and Finished, and then', () => {
      beforeEach(async () => {
        const data = await client.recv(TEST_VECTORS.SERVER_ENCRYPTED_EXTENSIONS_AND_FINISHED);
        assert.equal(data, null);
      });

      it('sends a Finished message in return', async () => {
        assert.equal(CLIENT_SENT.length, 2);
        assert.ok(bytesAreEqual(CLIENT_SENT[1], TEST_VECTORS.CLIENT_FINISHED));
      });

      it('can receive application data, calling crypto.subtle.decrypt to do the decryption', async () => {
        sinon.spy(crypto.subtle, 'decrypt');
        try {
          const data = await client.recv(TEST_VECTORS.SERVER_APP_DATA);
          assert.ok(bytesAreEqual(data, TEST_VECTORS.SERVER_RAW_APP_DATA));
          assert.equal(crypto.subtle.decrypt.callCount, 1);
        } finally {
          crypto.subtle.decrypt.restore();
        }
      });

      it('can send application data, calling crypto.subtle.encrypt to do the encryption', async () => {
        sinon.spy(crypto.subtle, 'encrypt');
        try {
          await client.send(TEST_VECTORS.CLIENT_RAW_APP_DATA);
          assert.equal(CLIENT_SENT.length, 3);
          assert.ok(bytesAreEqual(CLIENT_SENT[2], TEST_VECTORS.CLIENT_APP_DATA));
          assert.equal(crypto.subtle.encrypt.callCount, 1);
        } finally {
          crypto.subtle.encrypt.restore();
        }
      });

      describe('handles first exchange of application data, and then', () => {
        beforeEach(async () => {
          await client.send(TEST_VECTORS.SERVER_RAW_APP_DATA);
          assert.equal(CLIENT_SENT.length, 3);
          assert.ok(bytesAreEqual(CLIENT_SENT[2], TEST_VECTORS.CLIENT_APP_DATA));
          const data = await client.recv(TEST_VECTORS.SERVER_APP_DATA);
          assert.ok(bytesAreEqual(data, TEST_VECTORS.SERVER_RAW_APP_DATA));
        });

        describe('handles second exchange of application data, and then', () => {
          beforeEach(async () => {
            await client.send(TEST_VECTORS.CLIENT_RAW_APP_DATA_2);
            assert.equal(CLIENT_SENT.length, 4);
            assert.ok(bytesAreEqual(CLIENT_SENT[3], TEST_VECTORS.CLIENT_APP_DATA_2));
            const data = await client.recv(TEST_VECTORS.SERVER_APP_DATA_2);
            assert.ok(bytesAreEqual(data, TEST_VECTORS.SERVER_RAW_APP_DATA_2));
          });

          describe('accepts an explicit close alert from the server, and then', () => {
            beforeEach(async () => {
              assert.throwsAsync(async () => {
                await client.recv(TEST_VECTORS.SERVER_CLOSE);
              }, TLSCloseNotify);
            });

            it('does not accept any additional received data', async () => {
              const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverApplicationTrafficSecret, 3);
              await assert.throwsAsync(async () => {
                await client.recv(await testHelpers.makeEncryptedRecord(encryptor, {}));
              }, TLSCloseNotify);
            });

            it('can still send data', async () => {
              await client.send(TEST_VECTORS.CLIENT_RAW_APP_DATA);
              assert.equal(CLIENT_SENT.length, 5);
            });

            describe('is able to send an explicit close in return, and then', () => {
              beforeEach(async () => {
                await client.close();
                assert.equal(CLIENT_SENT.length, 5);
                assert.ok(bytesAreEqual(CLIENT_SENT[4], TEST_VECTORS.CLIENT_CLOSE));
              });

              it('rejects any further attempts to send data', async () => {
                await assert.throwsAsync(async () => {
                  await client.send(TEST_VECTORS.CLIENT_RAW_APP_DATA);
                }, TLSCloseNotify);
              });
            });
          });

          describe('can send explicit close alert to the server, and then', () => {
            beforeEach(async () => {
              await client.close();
              assert.equal(CLIENT_SENT.length, 5);
              assert.ok(bytesAreEqual(CLIENT_SENT[4], TEST_VECTORS.CLIENT_CLOSE));
            });

            it('rejects any further attempts to send data', async () => {
              await assert.throwsAsync(async () => {
                await client.send(TEST_VECTORS.CLIENT_RAW_APP_DATA);
              }, TLSCloseNotify);
            });

            it('can still receive more data from the server', async () => {
              const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverApplicationTrafficSecret, 2);
              const data = await client.recv(await testHelpers.makeEncryptedRecord(encryptor, {
                content: utf8ToBytes('hello world')
              }));
              assert.equal(bytesToUtf8(data), 'hello world');
            });

            describe('is able to receive an explicit close in return, and then', () => {
              beforeEach(async () => {
                assert.throwsAsync(async () => {
                  await client.recv(TEST_VECTORS.SERVER_CLOSE);
                }, TLSCloseNotify);
              });

              it('does not accept any additional received data', async () => {
                const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverApplicationTrafficSecret, 3);
                await assert.throwsAsync(async () => {
                  await client.recv(await testHelpers.makeEncryptedRecord(encryptor, {}));
                }, TLSCloseNotify);
              });
            });
          });

          it('errors if receiving a close_notify alert with fatal alert level', async () => {
            const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverApplicationTrafficSecret, 2);
            await assert.throwsAsync(async () => {
              await client.recv(await testHelpers.makeEncryptedRecord(encryptor, {
                content: arrayToBytes([2, 0]),
                type: 21
              }));
            }, TLSError, 'ILLEGAL_PARAMETER');
          });
        });

        it('rejects an out-of-order close notification', async () => {
          // The `TEST_VECTORS.SERVER_CLOSE` record was generated after sending two application
          // data records, but here we're receiving it after only processing one of them.
          await assert.throwsAsync(async () => {
            await client.recv(TEST_VECTORS.SERVER_CLOSE);
          }, TLSError, 'BAD_RECORD_MAC');
        });

        it('rejects a duplicate application data record', async () => {
          await assert.throwsAsync(async () => {
            await client.recv(TEST_VECTORS.SERVER_APP_DATA);
          }, TLSError, 'BAD_RECORD_MAC');
        });
      });

      it('accepts and ignores a NewSessionTicket message', async () => {
        const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverApplicationTrafficSecret, 0);
        const newSessionTicket = new NewSessionTicket(0, 0, zeros(32), zeros(32), []);
        const data = await client.recv(await testHelpers.makeEncryptedRecord(encryptor, {
          content: newSessionTicket.toBytes(),
          type: 22,
        }));
        assert.equal(data, null);
      });

      it('errors if it receives an invalid NewSessionTicket message', async () => {
        const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverApplicationTrafficSecret, 0);
        const newSessionTicket = new NewSessionTicket(0, 0, zeros(0), zeros(0), []); // a zero-length ticket is invalid
        await assert.throwsAsync(async () => {
          await client.recv(await testHelpers.makeEncryptedRecord(encryptor, {
            content: newSessionTicket.toBytes(),
            type: 22,
          }));
        }, TLSError, 'DECODE_ERROR');
      });

      it('errors if it receives another handshake message', async () => {
        const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverApplicationTrafficSecret, 0);
        await assert.throwsAsync(async () => {
          await client.recv(await testHelpers.makeEncryptedRecord(encryptor, {
            content: new Finished(zeros(32)).toBytes(),
            type: 22,
          }));
        }, TLSError, 'UNEXPECTED_MESSAGE');
      });

      it('errors if a data record is received out-of-order', async () => {
        await assert.throwsAsync(async () => {
          await client.recv(TEST_VECTORS.SERVER_APP_DATA_2);
        }, TLSError, 'BAD_RECORD_MAC');
      });

      it('errors if a data record is tampered with', async () => {
        await assert.throwsAsync(async () => {
          await client.recv(testHelpers.tamper(TEST_VECTORS.SERVER_APP_DATA, 5));
        }, TLSError, 'BAD_RECORD_MAC');
      });

      it('errors if change_cipher_spec is received after handshake completion', async () => {
        await assert.throwsAsync(async () => {
          await client.recv(TEST_VECTORS.SERVER_CHANGE_CIPHER_SPEC);
        }, TLSError, 'UNEXPECTED_MESSAGE');
      });
    });

    it('accepts and ignores a change_cipher_spec message after the ServerHello', async () => {
      const data = await client.recv(TEST_VECTORS.SERVER_CHANGE_CIPHER_SPEC);
      assert.equal(data, null);
    });

    it('rejects duplicate change_cipher_spec message after the ServerHello', async () => {
      const data = await client.recv(TEST_VECTORS.SERVER_CHANGE_CIPHER_SPEC);
      assert.equal(data, null);
      assert.throwsAsync(async () => {
        await client.recv(TEST_VECTORS.SERVER_CHANGE_CIPHER_SPEC);
      }, TLSError, 'UNEXPECTED_MESSAGE');
    });

    it('would error out if some bug caused it to try to send application data before handshake completion', async () => {
      await assert.throwsAsync(async () => {
        await client._state.sendApplicationData(zeros(12));
      }, TLSError, 'INTERNAL_ERROR');
    });

    it('cant yet decrypt application data, since it does not have the right keys', async () => {
      await assert.throwsAsync(async () => {
        await client.recv(TEST_VECTORS.SERVER_APP_DATA);
      }, TLSError, 'BAD_RECORD_MAC');
    });

    it('errors if it receives application data before the handshake completes', async () => {
      const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverHandshakeTrafficSecret, 0);
      await assert.throwsAsync(async () => {
        await client.recv(await testHelpers.makeEncryptedRecord(encryptor, {}));
      }, TLSError, 'UNEXPECTED_MESSAGE');
    });

    it('errors if it receives Finished before EncryptedExtensions', async () => {
      const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverHandshakeTrafficSecret, 0);
      const encCert = await testHelpers.makeEncryptedRecord(encryptor, {
        content: new Finished(zeros(32)).toBytes(),
        type: 22,
      });
      await assert.throwsAsync(async () => {
        await client.recv(encCert);
      }, TLSError, 'UNEXPECTED_MESSAGE');
    });

    it('errors if it receives a Certificate before EncryptedExtensions', async () => {
      const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverHandshakeTrafficSecret, 0);
      const encCert = await testHelpers.makeEncryptedRecord(encryptor, {
        content: await testHelpers.makeHandshakeMessage({
          type: 11
        }),
        type: 22,
      });
      await assert.throwsAsync(async () => {
        await client.recv(encCert);
      }, TLSError, 'UNEXPECTED_MESSAGE');
    });

    it('errors if it receives a Certificate after EncryptedExtensions', async () => {
      const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverHandshakeTrafficSecret, 0);
      const recordContent = new BufferWriter();
      recordContent.writeBytes(await testHelpers.makeEncryptedExtensionsMessage({}));
      recordContent.writeBytes(await testHelpers.makeHandshakeMessage({
        type: 11
      }));
      const encExtAndCert = await testHelpers.makeEncryptedRecord(encryptor, {
        content: recordContent.flush(),
        type: 22,
      });
      await assert.throwsAsync(async () => {
        await client.recv(encExtAndCert);
      }, TLSError, 'UNEXPECTED_MESSAGE');
    });

    it('errors if it receives something other than Finished after EncryptedExtensions', async () => {
      const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverHandshakeTrafficSecret, 0);
      const recordContent = new BufferWriter();
      recordContent.writeBytes(await testHelpers.makeEncryptedExtensionsMessage({}));
      recordContent.writeBytes(await testHelpers.makeEncryptedExtensionsMessage({}));
      recordContent.writeBytes(new Finished(zeros(32)).toBytes());
      const encExtAndCert = await testHelpers.makeEncryptedRecord(encryptor, {
        content: recordContent.flush(),
        type: 22,
      });
      await assert.throwsAsync(async () => {
        await client.recv(encExtAndCert);
      }, TLSError, 'UNEXPECTED_MESSAGE');
    });

    it('errors if it receives a bad Finished MAC', async () => {
      const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverHandshakeTrafficSecret, 0);
      const recordContent = new BufferWriter();
      recordContent.writeBytes(await testHelpers.makeEncryptedExtensionsMessage({}));
      recordContent.writeBytes(new Finished(zeros(32)).toBytes());
      const encExtAndFinished = await testHelpers.makeEncryptedRecord(encryptor, {
        content: recordContent.flush(),
        type: 22,
      });
      await assert.throwsAsync(async () => {
        await client.recv(encExtAndFinished);
      }, TLSError, 'DECRYPT_ERROR');
    });

    it('errors if it receives a SupportedVersions inside EncryptedExtensions', async () => {
      const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverHandshakeTrafficSecret, 0);
      const encExt = await testHelpers.makeEncryptedRecord(encryptor, {
        content: await testHelpers.makeEncryptedExtensionsMessage({
          extensions: [testHelpers.makeSupportedVersionsExtension([])]
        }),
        type: 22,
      });
      await assert.throwsAsync(async () => {
        await client.recv(encExt);
      }, TLSError, 'ILLEGAL_PARAMETER');
    });

    it('errors if it receives a PreSharedKey inside EncryptedExtensions', async () => {
      const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverHandshakeTrafficSecret, 0);
      const encExt = await testHelpers.makeEncryptedRecord(encryptor, {
        content: await testHelpers.makeEncryptedExtensionsMessage({
          extensions: [testHelpers.makePreSharedKeyExtension([zeros(32)], [zeros(32)])]
        }),
        type: 22,
      });
      await assert.throwsAsync(async () => {
        await client.recv(encExt);
      }, TLSError, 'ILLEGAL_PARAMETER');
    });

    it('errors if it receives a PskKeyExchangeModes inside EncryptedExtensions', async () => {
      const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverHandshakeTrafficSecret, 0);
      const encExt = await testHelpers.makeEncryptedRecord(encryptor, {
        content: await testHelpers.makeEncryptedExtensionsMessage({
          extensions: [testHelpers.makePskKeyExchangeModesExtension([0x00])]
        }),
        type: 22,
      });
      await assert.throwsAsync(async () => {
        await client.recv(encExt);
      }, TLSError, 'ILLEGAL_PARAMETER');
    });

    it('errors if it receives a non-empty EncryptedExtensions', async () => {
      const encryptor = await testHelpers.makeEncryptionState(client._keyschedule.serverHandshakeTrafficSecret, 0);
      const encExt = await testHelpers.makeEncryptedRecord(encryptor, {
        content: await testHelpers.makeEncryptedExtensionsMessage({
          extensions: [testHelpers.makeCookieExtension(zeros(7))]
        }),
        type: 22,
      });
      await assert.throwsAsync(async () => {
        await client.recv(encExt);
      }, TLSError, 'UNSUPPORTED_EXTENSION');
    });
  });

  it('accepts a ServerHello with extensions listed in a different order', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          testHelpers.makePreSharedKeyExtension(0),
          testHelpers.makeSupportedVersionsExtension(0x0304)
        ]
      }),
      type: 22
    });
    const data = await client.recv(serverHello);
    assert.equal(data, null);
  });

  it('blocks sending of application data until the handshake completes', async () => {
    let sendComplete = false;
    client.send(TEST_VECTORS.CLIENT_RAW_APP_DATA).then(() => {
      sendComplete = true;
    });
    assert.equal(CLIENT_SENT.length, 1);
    assert.notOk(sendComplete);

    await client.recv(TEST_VECTORS.SERVER_HELLO);
    assert.equal(CLIENT_SENT.length, 1);
    await testHelpers.nextTick();
    assert.notOk(sendComplete);

    await client.recv(TEST_VECTORS.SERVER_ENCRYPTED_EXTENSIONS_AND_FINISHED);
    assert.equal(CLIENT_SENT.length, 2);
    assert.notOk(sendComplete);
    await testHelpers.nextTick();
    assert.ok(sendComplete);
  });

  it('rejects ChangeCipherSpec before it has received ServerHello', async () => {
    await assert.throwsAsync(async () => {
      await client.recv(TEST_VECTORS.SERVER_CHANGE_CIPHER_SPEC);
    }, TLSError, 'UNEXPECTED_MESSAGE');
  });

  it('errors if it receives non-TLS-handshake-message data', async () => {
    await assert.throwsAsync(async () => {
      await client.recv(utf8ToBytes('a badly-formed message'));
    }, TLSError, 'DECODE_ERROR');
  });

  it('errors if it receives a message of unknown type', async () => {
    await assert.throwsAsync(async () => {
      await client.recv(hexToBytes('0103030002AABB'));
    }, TLSError, 'UNEXPECTED_MESSAGE');
  });

  it('errors if it receives a message other than ServerHello', async () => {
    await assert.throwsAsync(async () => {
      await client.recv(TEST_VECTORS.CLIENT_HELLO);
    }, TLSError, 'UNEXPECTED_MESSAGE');
  });

  it('errors if the version number in the ServerHello predates TLS1.2', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        version: 0x0123
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if the ServerHello did not send supported_versions', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          testHelpers.makePreSharedKeyExtension(0)
        ]
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'MISSING_EXTENSION');
  });

  it('errors if the ServerHello did not negotiate TLS1.3', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          testHelpers.makePreSharedKeyExtension(1),
          testHelpers.makeSupportedVersionsExtension(0x0303)
        ]
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if the ServerHello tried to negotiate TLS1.3 via legacy_version field', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          testHelpers.makePreSharedKeyExtension(1),
          testHelpers.makeSupportedVersionsExtension(0x0304)
        ],
        version: 0x0304
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if ServerHello did not select the right CipherSuite', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        ciphersuite: 0x0123
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if the ServerHello did not select a PSK', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          testHelpers.makeSupportedVersionsExtension(0x0304)
        ]
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'MISSING_EXTENSION');
  });

  it('errors if ServerHello did not select the right PSK', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          testHelpers.makePreSharedKeyExtension(1),
          testHelpers.makeSupportedVersionsExtension(0x0304)
        ]
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if ServerHello tried to use a non-zero compression method', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        compressionMethod: 0x01
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if ServerHello did not echo our sessionId', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        sessionId: zeros(32)
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if the ServerHello contained an extension not allowed in that message', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          testHelpers.makeSupportedVersionsExtension(0x0304),
          testHelpers.makePskKeyExchangeModesExtension([]),
          testHelpers.makePreSharedKeyExtension(0)
        ]
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'ILLEGAL_PARAMETER');
  });

  it('errors if the ServerHello contained unexpected extensions', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          testHelpers.makeSupportedVersionsExtension(0x0304),
          testHelpers.makeCookieExtension(zeros(12)),
          testHelpers.makePreSharedKeyExtension(0)
        ]
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'UNSUPPORTED_EXTENSION');
  });

  it('errors if the ServerHello contained duplicate extensions', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          testHelpers.makeSupportedVersionsExtension(0x0304),
          testHelpers.makeSupportedVersionsExtension(0x0305),
          testHelpers.makePreSharedKeyExtension(0)
        ]
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'DECODE_ERROR');
  });

  it('errors if the ServerHello contained an extension whose length field is too small', async () => {
    const svExt = testHelpers.makeSupportedVersionsExtension(0x0304);
    svExt.length = svExt.data.byteLength - 1;
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          svExt,
          testHelpers.makePreSharedKeyExtension(0)
        ]
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'DECODE_ERROR');
  });

  it('errors if the ServerHello contained an extension whose length field is too big', async () => {
    const svExt = testHelpers.makeSupportedVersionsExtension(0x0304);
    svExt.length = svExt.data.byteLength + 1;
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          svExt,
          testHelpers.makePreSharedKeyExtension(0)
        ]
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'DECODE_ERROR');
  });

  it('errors if the ServerHello has trailing data', async () => {
    const serverHello = testHelpers.makePlaintextRecord({
      content: await testHelpers.makeServerHelloMessage({
        extensions: [
          testHelpers.makeSupportedVersionsExtension(0x0304),
          testHelpers.makeSupportedVersionsExtension(0x0305),
          testHelpers.makePreSharedKeyExtension(0)
        ],
        trailer: zeros(3),
      }),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'DECODE_ERROR');
  });

  it('errors if ServerHello and EncryptedExtensions appear in the same record', async () => {
    const contentBuf = new BufferWriter();
    contentBuf.writeBytes(await testHelpers.makeServerHelloMessage({
      extensions: [
        testHelpers.makeSupportedVersionsExtension(0x0304),
        testHelpers.makePreSharedKeyExtension(0)
      ]
    }));
    contentBuf.writeBytes(new EncryptedExtensions([]).toBytes());
    const serverHello = testHelpers.makePlaintextRecord({
      content: contentBuf.flush(),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'UNEXPECTED_MESSAGE');
  });

  it('errors if receiving a completely unknown handshake message type', async () => {
    const contentBuf = new BufferWriter();
    contentBuf.writeUint8(99);
    contentBuf.writeVectorBytes24(zeros(0));
    const unknownMessage = testHelpers.makePlaintextRecord({
      content: contentBuf.flush(),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(unknownMessage);
    }, TLSError, 'UNEXPECTED_MESSAGE');
  });

  it('errors if ServerHello has a partial EncryptedExtensions after it in the same record', async () => {
    const contentBuf = new BufferWriter();
    contentBuf.writeBytes(await testHelpers.makeServerHelloMessage({
      extensions: [
        testHelpers.makeSupportedVersionsExtension(0x0304),
        testHelpers.makePreSharedKeyExtension(0)
      ]
    }));
    contentBuf.writeBytes(new EncryptedExtensions([]).toBytes().slice(0, 4));
    const serverHello = testHelpers.makePlaintextRecord({
      content: contentBuf.flush(),
      type: 22
    });
    await assert.throwsAsync(async () => {
      await client.recv(serverHello);
    }, TLSError, 'UNEXPECTED_MESSAGE');
  });
});


describe('the handshake between ClientConnection and ServerConnection', () => {
  it('works without any mocking', async () => {
    const CLIENT_SENT = [], SERVER_SENT = [];
    const server = await ServerConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => SERVER_SENT.push(data));
    const client = await ClientConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => CLIENT_SENT.push(data));

    assert.equal(CLIENT_SENT.length, 1);
    await server.recv(CLIENT_SENT[0]); // CH
    assert.equal(SERVER_SENT.length, 3);
    await client.recv(SERVER_SENT[0]); // SH
    await client.recv(SERVER_SENT[1]); // CCS
    await client.recv(SERVER_SENT[2]); // EE+SF
    assert.equal(CLIENT_SENT.length, 2);
    await server.recv(CLIENT_SENT[1]); // CF
    assert.ok(bytesAreEqual(
      server._keyschedule.clientApplicationTrafficSecret,
      client._keyschedule.clientApplicationTrafficSecret
    ));
    assert.ok(bytesAreEqual(
      server._keyschedule.serverApplicationTrafficSecret,
      client._keyschedule.serverApplicationTrafficSecret
    ));

    await client.send(utf8ToBytes('hello world'));
    assert.equal(CLIENT_SENT.length, 3);
    const data = await server.recv(CLIENT_SENT[2]);
    assert.equal(bytesToUtf8(data), 'hello world');

    await server.close();
    assert.equal(SERVER_SENT.length, 4);
    assert.throwsAsync(async () => {
      await client.recv(SERVER_SENT[3]);
    }, TLSCloseNotify);

    await client.close();
    assert.equal(CLIENT_SENT.length, 4);
    assert.throwsAsync(async () => {
      await server.recv(CLIENT_SENT[3]);
    }, TLSCloseNotify);
  });

  it('closes cleanly when part-way through', async () => {
    const CLIENT_SENT = [], SERVER_SENT = [];
    const server = await ServerConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => SERVER_SENT.push(data));
    const client = await ClientConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => CLIENT_SENT.push(data));
    assert.equal(CLIENT_SENT.length, 1);
    await server.recv(CLIENT_SENT[0]);
    assert.equal(SERVER_SENT.length, 3);
    await client.recv(SERVER_SENT[0]);
    await client.close();
    assert.equal(CLIENT_SENT.length, 2);
    assert.throwsAsync(async () => {
      await server.recv(CLIENT_SENT[1]);
    }, TLSCloseNotify);
    await server.close();
    assert.equal(SERVER_SENT.length, 4);
    assert.throwsAsync(async () => {
      await client.recv(SERVER_SENT[3]);
    }, TLSCloseNotify);
  });

  it('rejects the `connected` promise on failure', async () => {
    const CLIENT_SENT = [], SERVER_SENT = [];
    const server = await ServerConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => SERVER_SENT.push(data));
    const client = await ClientConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => CLIENT_SENT.push(data));
    await assert.throwsAsync(async () => {
      await server.recv(utf8ToBytes('junk data'));
    }, TLSError, 'DECODE_ERROR');
    // The server's `connected` promise rejects with that error.
    await assert.throwsAsync(async () => {
      await server.connected;
    }, TLSError, 'DECODE_ERROR');
    // The server sends the error to the client, which also rejects with it.
    await assert.throwsAsync(async () => {
      await client.recv(SERVER_SENT[0]);
    }, TLSError, 'DECODE_ERROR');
    await assert.throwsAsync(async () => {
      await client.connected;
    }, TLSError, 'DECODE_ERROR');
  });

  it('fulfills the `connected` promise on success', async () => {
    const CLIENT_SENT = [], SERVER_SENT = [];
    const server = await ServerConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => SERVER_SENT.push(data));
    const client = await ClientConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => CLIENT_SENT.push(data));
    await assert.promiseIsPending(client.connected);
    await assert.promiseIsPending(server.connected);

    await server.recv(CLIENT_SENT[0]); // CH
    await client.recv(SERVER_SENT[0]); // SH
    await client.recv(SERVER_SENT[1]); // CCS
    await assert.promiseIsPending(client.connected);
    await assert.promiseIsPending(server.connected);

    await client.recv(SERVER_SENT[2]); // EE+SF
    await client.connected;
    await assert.promiseIsPending(server.connected);

    await server.recv(CLIENT_SENT[1]); // CF
    await server.connected;
  });

  it('generates fresh randomness on each run', async () => {
    const CLIENT1_SENT = [], CLIENT2_SENT = [];
    const SERVER1_SENT = [], SERVER2_SENT = [];
    const server1 = await ServerConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => SERVER1_SENT.push(data));
    const server2 = await ServerConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => SERVER2_SENT.push(data));
    const client1 = await ClientConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => CLIENT1_SENT.push(data));
    const client2 = await ClientConnection.create(TEST_VECTORS.PSK, TEST_VECTORS.PSK_ID, data => CLIENT2_SENT.push(data));
    assert.notOk(bytesAreEqual(CLIENT1_SENT[0], CLIENT2_SENT[0])); // ClientHello differs
    await server1.recv(CLIENT1_SENT[0]); // CH1
    await server2.recv(CLIENT2_SENT[0]); // CH2
    assert.notOk(bytesAreEqual(SERVER1_SENT[0], SERVER2_SENT[0])); // ServerHello differs
    assert.ok(bytesAreEqual(SERVER1_SENT[1], SERVER2_SENT[1])); // ChaneCipherSpec is the same
    assert.notOk(bytesAreEqual(SERVER1_SENT[2], SERVER2_SENT[2])); // Encrypted handshake msgs differ
    await client1.recv(SERVER1_SENT[0]); // SH1
    await client1.recv(SERVER1_SENT[1]); // CCS1
    await client1.recv(SERVER1_SENT[2]); // EE1+SF1
    await client2.recv(SERVER2_SENT[0]); // SH2
    await client2.recv(SERVER2_SENT[1]); // CCS2
    await client2.recv(SERVER2_SENT[2]); // EE2+SF2
    await server1.recv(CLIENT1_SENT[1]); // CF1
    await server2.recv(CLIENT2_SENT[1]); // CF2
    // The final keys differ
    assert.notOk(bytesAreEqual(
      server1._keyschedule.clientApplicationTrafficSecret,
      server2._keyschedule.clientApplicationTrafficSecret
    ));
    assert.notOk(bytesAreEqual(
      client1._keyschedule.serverApplicationTrafficSecret,
      client2._keyschedule.serverApplicationTrafficSecret
    ));
  });
});
